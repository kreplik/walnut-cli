"""
ETHDebug Parser for EVM Debugging

Parses ethdebug format debug information generated by solc compiler.
"""

import json
import os
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass, field
from pathlib import Path

from soldb.colors import warning


@dataclass
class SourceLocation:
    """Represents a source code location."""
    source_id: int
    offset: int
    length: int
    
    def __repr__(self):
        return f"Source({self.source_id}:{self.offset}+{self.length})"


@dataclass
class Instruction:
    """Represents a single EVM instruction with debug info."""
    offset: int  # Bytecode offset
    operation: Dict[str, Any]  # mnemonic and arguments
    context: Optional[Dict[str, Any]] = None  # Source mapping context
    
    @property
    def mnemonic(self) -> str:
        return self.operation.get('mnemonic', '')
    
    @property
    def arguments(self) -> List[str]:
        return self.operation.get('arguments', [])
    
    @property
    def source_location(self) -> Optional[SourceLocation]:
        if not self.context or 'code' not in self.context:
            return None
        
        code_info = self.context['code']
        if 'source' in code_info and 'range' in code_info:
            return SourceLocation(
                source_id=code_info['source']['id'],
                offset=code_info['range']['offset'],
                length=code_info['range']['length']
            )
        return None


@dataclass
class VariableLocation:
    """Represents a variable's location in stack/memory/storage."""
    name: str
    type: str
    location_type: str  # "stack", "memory", "storage"
    offset: int
    pc_range: Tuple[int, int]  # (start_pc, end_pc)
    
    def is_active_at_pc(self, pc: int) -> bool:
        """Check if this variable is active at the given PC."""
        return self.pc_range[0] <= pc <= self.pc_range[1]


@dataclass
class ETHDebugInfo:
    """Container for ethdebug debugging information."""
    compilation: Dict[str, Any]
    contract_name: str
    environment: str  # 'create' or 'runtime'
    instructions: List[Instruction]
    sources: Dict[int, str]  # source_id -> file path
    variable_locations: Dict[int, List[VariableLocation]] = field(default_factory=dict)  # PC -> variables
    
    def get_instruction_at_pc(self, pc: int) -> Optional[Instruction]:
        """Get instruction at specific program counter."""
        for instruction in self.instructions:
            if instruction.offset == pc:
                return instruction
        return None
    
    def get_source_info(self, pc: int) -> Optional[Tuple[str, int, int]]:
        """Get source file and location for PC."""
        instruction = self.get_instruction_at_pc(pc)
        if not instruction or not instruction.source_location:
            return None
        
        source_loc = instruction.source_location
        source_file = self.sources.get(source_loc.source_id)
        if not source_file:
            return None
        
        return (source_file, source_loc.offset, source_loc.length)
    
    def get_variables_at_pc(self, pc: int) -> List[VariableLocation]:
        """Get all variables active at the given PC."""
        # First check if we have exact PC match
        if pc in self.variable_locations:
            return self.variable_locations[pc]
        
        # Otherwise, find all variables whose range includes this PC
        active_vars = []
        for _, var_list in self.variable_locations.items():
            for var in var_list:
                if var.is_active_at_pc(pc):
                    active_vars.append(var)
        
        return active_vars


class ETHDebugParser:
    """Parser for ethdebug format debug information."""
    
    def __init__(self):
        self.debug_info: Optional[ETHDebugInfo] = None
        self.source_cache: Dict[str, List[str]] = {}
    
    def load_ethdebug_files(self, debug_dir: Union[str, Path], contract_name: Optional[str] = None) -> ETHDebugInfo:
        """Load ethdebug files from a directory."""
        debug_dir = Path(debug_dir)
        # Store debug directory for source file resolution
        self.debug_dir = debug_dir
        
        # Load compilation info
        compilation_file = debug_dir / "ethdebug.json"
        if not compilation_file.exists():
            raise FileNotFoundError(f"ethdebug.json not found in {debug_dir}")
        
        with open(compilation_file) as f:
            compilation_data = json.load(f)
        
        # Build source mapping
        sources = {}
        for source in compilation_data['compilation']['sources']:
            sources[source['id']] = source['path']
        
        debug_file = None
        environment = None

        if contract_name:
            # Find source that contains contract_name in its path
            target_source_id = None
            for source_id, source_path in sources.items():
                if contract_name.lower() in source_path.lower():
                    target_source_id = source_id
                    break
            
            if target_source_id is None:
                # Fallback: try to find by filename
                for source_id, source_path in sources.items():
                    filename = os.path.splitext(os.path.basename(source_path))[0]
                    if filename.lower() == contract_name.lower():
                        target_source_id = source_id
                        break
            
            if target_source_id is None:
                raise FileNotFoundError(f"No source found containing contract name '{contract_name}' in sources: {list(sources.values())}")
            
            # Use the found source to determine contract name
            target_source_path = sources[target_source_id]
            contract_name_from_source = os.path.splitext(os.path.basename(target_source_path))[0]
            
            runtime_file = debug_dir / f"{contract_name_from_source}_ethdebug-runtime.json"
            create_file = debug_dir / f"{contract_name_from_source}_ethdebug.json"
            if runtime_file.exists():
                debug_file = runtime_file
                environment = 'runtime'
            elif create_file.exists():
                debug_file = create_file
                environment = 'create'
            else:
                raise FileNotFoundError(f"No ethdebug file found for contract {contract_name_from_source} in {debug_dir}")
        else:
            ethdebug_files = list(debug_dir.glob("*_ethdebug.json"))
            runtime_files = list(debug_dir.glob("*_ethdebug-runtime.json"))
            
            # Use first source path from sources as path
            if sources:
                first_source_path = next(iter(sources.values()))
                contract_name_guess = os.path.splitext(os.path.basename(first_source_path))[0]
                runtime_file = debug_dir / f"{contract_name_guess}_ethdebug-runtime.json"
                create_file = debug_dir / f"{contract_name_guess}_ethdebug.json"
                if runtime_file.exists():
                    debug_file = runtime_file
                    environment = 'runtime'
                elif create_file.exists():
                    debug_file = create_file
                    environment = 'create'
                else:
                    raise FileNotFoundError(f"No ethdebug file found for contract {contract_name_guess} in {debug_dir} (tried {runtime_file.name} i {create_file.name})")
            

        # Extract contract name from filename (for info only)
        contract_name_from_file = debug_file.stem.replace('_ethdebug-runtime', '').replace('_ethdebug', '')

        # Load contract debug info
        with open(debug_file) as f:
            contract_data = json.load(f)
        
        # Parse instructions
        instructions = []
        for inst_data in contract_data.get('instructions', []):
            instruction = Instruction(
                offset=inst_data['offset'],
                operation=inst_data['operation'],
                context=inst_data.get('context')
            )
            instructions.append(instruction)
        
        # Parse variable locations (if available)
        variable_locations = self._parse_variable_locations(contract_data)
        
        # Use provided contract_name or fallback to filename
        final_contract_name = contract_name if contract_name else contract_name_from_file
        
        self.debug_info = ETHDebugInfo(
            compilation=compilation_data['compilation'],
            contract_name=final_contract_name,
            environment=environment,
            instructions=instructions,
            sources=sources,
            variable_locations=variable_locations
        )
        
        return self.debug_info
    
    def _parse_variable_locations(self, contract_data: Dict[str, Any]) -> Dict[int, List[VariableLocation]]:
        """Parse variable location information from ETHDebug data."""
        variable_locations = {}
        
        # Check for variable information in the ETHDebug data
        # The exact format depends on the ETHDebug specification
        # This is a placeholder implementation that can be extended
        # when the full ETHDebug variable format is available
        
        # Look for variable data in instructions
        for inst_data in contract_data.get('instructions', []):
            pc = inst_data['offset']
            context = inst_data.get('context', {})
            
            # Check if this instruction has variable information
            if 'variables' in context:
                var_list = []
                for var_data in context['variables']:
                    var_loc = VariableLocation(
                        name=var_data.get('name', 'unknown'),
                        type=var_data.get('type', 'unknown'),
                        location_type=var_data.get('location', {}).get('type', 'stack'),
                        offset=var_data.get('location', {}).get('offset', 0),
                        pc_range=(
                            var_data.get('scope', {}).get('start', pc),
                            var_data.get('scope', {}).get('end', pc)
                        )
                    )
                    var_list.append(var_loc)
                
                if var_list:
                    variable_locations[pc] = var_list
        
        # Also check for a separate variables section (future ETHDebug format)
        if 'variables' in contract_data:
            for var_data in contract_data['variables']:
                # Parse variable scope and location information
                pc_start = var_data.get('pc_start', 0)
                pc_end = var_data.get('pc_end', 0)
                
                var_loc = VariableLocation(
                    name=var_data.get('name', 'unknown'),
                    type=var_data.get('type', 'unknown'),
                    location_type=var_data.get('location_type', 'stack'),
                    offset=var_data.get('offset', 0),
                    pc_range=(pc_start, pc_end)
                )
                
                # Add to all PCs in range
                for pc in range(pc_start, pc_end + 1):
                    if pc not in variable_locations:
                        variable_locations[pc] = []
                    variable_locations[pc].append(var_loc)
        
        return variable_locations
    
    def load_source_file(self, source_path: str) -> List[str]:
        """Load and cache source file lines."""
        if source_path not in self.source_cache:
            self.source_cache[source_path] = self._find_and_load_source_file(source_path)
        return self.source_cache[source_path]
    
    def _find_and_load_source_file(self, source_path: str) -> List[str]:
        """Find and load a source file from various possible locations."""
        # Try direct path first
        result = self._try_load_file(Path(source_path))
        if result:
            return result
        
        # If we have debug directory info, try relative to that first
        if hasattr(self, 'debug_dir') and self.debug_dir:
            debug_relative_path = os.path.join(self.debug_dir, '..', source_path)
            debug_relative_path = os.path.normpath(debug_relative_path)
            if os.path.exists(debug_relative_path):
                with open(debug_relative_path) as f:
                    return f.readlines()
            
            # Fallback to the old method
            debug_dir = Path(self.debug_dir)
            filename = os.path.basename(source_path)
            contract_name = filename.replace('.sol', '')
            
            # Get all possible search locations
            search_locations = self._get_source_search_locations(debug_dir, filename, source_path)
            
            # Try each location
            for location in search_locations:
                result = self._try_load_file(location)
                if result:
                    return result
                
                # If it's a directory, try to find matching .sol file
                if location.exists() and location.is_dir():
                    result = self._find_matching_sol_file(location, contract_name)
                    if result:
                        return result
        
        # Fallback: search in current directory and parent directories
        filename = os.path.basename(source_path)
        current_dir = os.getcwd()
        
        for _ in range(4):
            for root, dirs, files in os.walk(current_dir):
                if filename in files:
                    full_path = Path(root) / filename
                    result = self._try_load_file(full_path)
                    if result:
                        return result
                # Don't go too deep
                if root.count(os.sep) - current_dir.count(os.sep) > 2:
                    break
            
            # Move up one directory
            parent = os.path.dirname(current_dir)
            if parent == current_dir:  # Reached root
                break
            current_dir = parent
        
        # Not found
        print(warning(f"Warning: Source file not found: {source_path}"))
        print(f"  Searched in debug directory: {getattr(self, 'debug_dir', 'None')}")
        return []
    
    def _get_source_search_locations(self, debug_dir: Path, filename: str, source_path: str) -> List[Path]:
        """Get all possible locations to search for source files."""
        locations = []
        
        
        # Direct file paths
        locations.extend([
            debug_dir / filename,
            debug_dir.parent / filename,
            debug_dir.parent.parent / filename,
            debug_dir.parent.parent / source_path,  # Try the full source path from parent
        ])
        
        # Common source directory patterns
        base_paths = [
            debug_dir.parent / "src",
            debug_dir.parent.parent / "src", 
            debug_dir.parent.parent / "contracts",
            debug_dir.parent.parent / "contracts" / "src",
            debug_dir.parent.parent / "src" / "contracts",
            debug_dir.parent.parent / "src" / "contracts" / "src",
        ]
        
        
        for base_path in base_paths:
            locations.extend([
                base_path / filename,
                base_path / source_path,  # Original source path
            ])
        
        # Generic fallback: try to find files with similar names in parent directories
        # This handles cases where source paths in metadata don't match actual file locations
        if "/" in source_path:
            # Try to find files with the same name in sibling directories
            source_parts = source_path.split("/")
            if len(source_parts) >= 2:
                # Get the directory structure up to the filename
                for i in range(len(source_parts) - 1):
                    # Try different variations of the path
                    for j in range(i + 1, len(source_parts)):
                        # Create alternative path by replacing directory names
                        alt_parts = source_parts[:i] + source_parts[j:]
                        alt_path = "/".join(alt_parts)
                        locations.append(debug_dir.parent.parent / alt_path)
                        
                        # Also try with just the filename in the parent directory
                        parent_dir = "/".join(source_parts[:i]) if i > 0 else ""
                        if parent_dir:
                            locations.append(debug_dir.parent.parent / parent_dir / filename)
        
        return locations
    
    def _try_load_file(self, file_path: Path) -> Optional[List[str]]:
        """Try to load a file and return its contents or None if failed."""
        if file_path.exists() and file_path.is_file():
            try:
                with open(file_path) as f:
                    return f.readlines()
            except (IsADirectoryError, PermissionError, UnicodeDecodeError) as e:
                print(warning(f"Warning: Cannot read source file {file_path}: {e}"))
        return None
    
    def _find_matching_sol_file(self, directory: Path, contract_name: str) -> Optional[List[str]]:
        """Find a matching .sol file in a directory by contract name."""
        try:
            for file in directory.iterdir():
                if file.is_file() and file.suffix == '.sol':
                    if contract_name in file.stem or file.stem in contract_name:
                        return self._try_load_file(file)
        except (OSError, PermissionError) as e:
            print(warning(f"Warning: Cannot list directory {directory}: {e}"))
        return None
    
    def offset_to_line_col(self, source_path: str, offset: int) -> Tuple[int, int]:
        """Convert byte offset to line and column in source file."""
        lines = self.load_source_file(source_path)
        
        current_offset = 0
        for line_num, line in enumerate(lines, 1):
            line_len = len(line)
            if current_offset + line_len > offset:
                col = offset - current_offset + 1
                return (line_num, col)
            current_offset += line_len
        
        return (1, 1)
    
    def get_source_mapping(self) -> Dict[int, Tuple[str, int, int]]:
        """Get PC to source line mapping."""
        if not self.debug_info:
            return {}
        
        pc_to_source = {}
        
        for instruction in self.debug_info.instructions:
            source_info = self.debug_info.get_source_info(instruction.offset)
            if source_info:
                source_path, offset, length = source_info
                line, col = self.offset_to_line_col(source_path, offset)
                pc_to_source[instruction.offset] = (source_path, line, col)
        
        return pc_to_source
    
    def get_source_context(self, pc: int, context_lines: int = 2) -> Optional[Dict[str, Any]]:
        """Get source code context around a PC."""
        if not self.debug_info:
            return None
        
        source_info = self.debug_info.get_source_info(pc)
        if not source_info:
            return None
        
        source_path, offset, length = source_info
        lines = self.load_source_file(source_path)
        line_num, col = self.offset_to_line_col(source_path, offset)
        
        # Get current line content
        current_content = ""
        if 0 < line_num <= len(lines):
            current_content = lines[line_num - 1].rstrip()
        
        # Get context lines
        start_line = max(1, line_num - context_lines)
        end_line = min(len(lines), line_num + context_lines)
        
        context = {
            'file': source_path,
            'line': line_num,
            'column': col,
            'content': current_content,  # Add the actual line content
            'context_lines': [],  # Changed from 'lines' to 'context_lines'
            'lines': []
        }
        
        # Include context lines for searching
        for i in range(start_line, end_line + 1):
            if i <= len(lines):
                context['context_lines'].append(lines[i-1].rstrip())
                context['lines'].append({
                    'number': i,
                    'content': lines[i-1].rstrip(),
                    'current': i == line_num
                })
        
        return context
    
    def format_instruction_debug(self, pc: int) -> str:
        """Format debug info for an instruction."""
        if not self.debug_info:
            return ""
        
        instruction = self.debug_info.get_instruction_at_pc(pc)
        if not instruction:
            return f"No debug info for PC {pc}"
        
        parts = [f"PC {pc}: {instruction.mnemonic}"]
        
        if instruction.arguments:
            parts.append(f"({', '.join(instruction.arguments)})")
        
        source_info = self.debug_info.get_source_info(pc)
        if source_info:
            source_path, offset, length = source_info
            line, col = self.offset_to_line_col(source_path, offset)
            parts.append(f"@ {os.path.basename(source_path)}:{line}:{col}")
        
        return " ".join(parts)
    
    def get_variables_debug_info(self, pc: int) -> Optional[Dict[str, Any]]:
        """Get variable information at a specific PC."""
        if not self.debug_info:
            return None
        
        variables = self.debug_info.get_variables_at_pc(pc)
        if not variables:
            return None
        
        return {
            'pc': pc,
            'variables': [
                {
                    'name': var.name,
                    'type': var.type,
                    'location': var.location_type,
                    'offset': var.offset
                }
                for var in variables
            ]
        }
    
    def format_variables_debug(self, pc: int, stack: Optional[List[int]] = None, 
                             memory: Optional[bytes] = None, 
                             storage: Optional[Dict[int, int]] = None) -> str:
        """Format variable values for debugging display."""
        var_info = self.get_variables_debug_info(pc)
        if not var_info or not var_info['variables']:
            return ""
        
        lines = ["Local Variables:"]
        for var in var_info['variables']:
            value_str = "?"
            
            # Try to get the actual value based on location
            if var['location'] == 'stack' and stack and var['offset'] < len(stack):
                value_str = hex(stack[var['offset']])
            elif var['location'] == 'memory' and memory:
                # For memory, we'd need to decode based on type
                value_str = "<memory>"
            elif var['location'] == 'storage' and storage and var['offset'] in storage:
                value_str = hex(storage[var['offset']])
            
            lines.append(f"  - {var['name']}: {value_str} ({var['type']}) @ {var['location']}[{var['offset']}]")
        
        return "\n".join(lines)
